#' Calculate the proportion of peaks with a motif
#'
#' \code{peak_proportion()} calculates the proportion of peaks containing a
#' motif. To generate a plot the peak file must contain a column that can be
#' used for ranking (e.g. p-values, q-values or signal values).
#'
#' @import rtracklayer
#' @import GenomicRanges
#' @import BSgenome
#' @import BSgenome.Hsapiens.UCSC.hg38
#' @import TFBSTools
#'
#' @param peak_input Either a path to the narrowPeak file or a GRanges peak
#' object generated by \code{read_peak_file()}.
#' @param pwm An object of class PWMatrix.
#' @param min_score Numeric specifying the minimum score a sequence must pass
#' to be considered a motif.
#' @param optimal_min_score If TRUE, numerical optimisation is used to find an
#' optimal min_score parameter for the motif search
#' @param seed Set this to an integer if you want the same random background
#' sequences across function calls (given the same peak_input). This parameter
#' is ignored when optimal_min_score is \code{FALSE}.
#'
#' @examples
#' \dontrun{
#'
#' peak_file <- system.file("extdata",
#'                          "rep1_peaks.narrowPeak",
#'                          package = "MotifStats"
#'                          )
#' data("creb_motif", package = "MotifStats")
#'
#' peak_proportion(
#'   peak_file = peak_file,
#'   pwm = creb_motif,
#'   genome_build = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38,
#'   min_score = NULL,
#'   optimal_min_score = TRUE,
#'   seed = 123 # set seed for reproducibility
#' )
#' }
#'
#' @export
peak_proportion <- function(peak_input,
                            pwm,
                            genome_build,
                            min_score = 0.8,
                            optimal_min_score = FALSE,
                            seed = NULL) {
  if(!is.null(seed)) set.seed(seed)

  if (is.character(peak_input)) {
    normalizePath(peak_input, mustWork = "TRUE") # error if path is invalid
    peaks <- read_peak_file(peak_input)
  } else if (inherits(peak_input, "GRanges")) {
    peaks <- peak_input
  } else {
    stopper(
      "peak_input must be a path to a peak file or a GRanges object",
      "with a 0-based summit column. This can be generated using",
      "read_peak_file(file_path)."
    )
  }
  ctrl_sequences <- adjacent_sequences(peaks)

  if (optimal_min_score) {
    min_score <- optimal_min_score(
      peaks = peaks,
      pwm = pwm,
      genome_build = genome_build
    )
    messager("Optimal min_score found:", min_score)

  } else if (!is.null(min_score)) {
    min_score <- min_score

  } else {
    stopper("Either optimal_min_score is set to TRUE or min_score must be",
            "supplied.")
  }

  hits <- get_motif_hits(
    peaks = peaks,
    pwm = pwm,
    min_score = min_score,
    genome_build = genome_build
  )
  ctrl_hits <- get_motif_hits(
    peaks = ctrl_sequences,
    pwm = pwm,
    min_score = min_score,
    genome_build = genome_build
  )

  sig <- TFBSTools::relScore(hits)
  ctrl_sig <- TFBSTools::relScore(ctrl_hits)

  # 1 motif per peak
  onehit_peak_names <- names(sig)[sapply(sig, length) > 0]
  onehit_peaks <- peaks[names(peaks) %in% onehit_peak_names,]

  onehit_ctrl_names <- names(ctrl_sig)[sapply(ctrl_sig, length) > 0]
  onehit_ctrl <-
    ctrl_sequences[names(ctrl_sequences) %in% onehit_ctrl_names,]

  # > 1 motif per peak
  mt1_peak_names <- names(sig)[sapply(sig, length) > 1]
  mt1_peaks <- peaks[names(peaks) %in% mt1_peak_names,]

  mt1_ctrl_names <- names(ctrl_sig)[sapply(ctrl_sig, length) > 1]
  mt1_ctrl <-
    ctrl_sequences[names(ctrl_sequences) %in% mt1_ctrl_names,]

  return(
    list(
      one_hit_peak_prop = onehit_peaks,
      proportion_1_motif = length(onehit_peaks) / length(peaks),
      ctrl_proportion_1_motif = length(onehit_ctrl) / length(ctrl_sequences),
      mt1_hit_peak_prop = mt1_peaks,
      proportion_mt1_motifs = length(mt1_peaks) / length(peaks),
      ctrl_mt1_proportion = length(mt1_ctrl) / length(ctrl_sequences)
    )
  )
}
