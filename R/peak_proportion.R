#' Calculate the proportion of peaks with a motif
#'
#' \code{peak_proportion()} calculates the proportion of peaks containing a
#' motif relative to a set of background sequences.
#'
#' When scanning sequences for the presence of a given motif, a difficult task
#' is selecting a suitable threshold for a "hit". This process typically
#' involves using a position weight matrix (PWM) to score each sequence based on
#' its similarity to a motif of interest. A score threshold representing the
#' proportion of the PWM's maximum possible score is then applied to filter for
#' significant matches.
#'
#' The peak_proportion() function uses \code{TFBSTools::searchSeq()} to find
#' motif occurrences. Similar to above, \code{searchSeq} uses
#' a \code{min.score} threshold to filter significant hits. We have found that
#' the optimal \code{min.score} threshold is highly sensitive to the particular
#' motif you are scanning. To make the process of selecting a score threshold
#' more seamless, we supply the option to use differential evolution
#' optimisation to find the score threshold that minimises
#' Loss = Proportion(background sequences with motif) - Proportion(peak
#' sequences with motif).
#'
#' @importFrom BSgenome getSeq
#'
#' @param peak_input Either a path to the narrowPeak file or a GRanges peak
#' object generated by \code{read_peak_file()}.
#' @param control_input Method for generating control sequences.
#' \code{"shuffle"} will shuffle the input sequences. \code{"adjacent"} will
#' select real sequences immediately adjacent to each peak. The default is
#' \code{"shuffle"}.
#' @param pwm An object of class \code{PWMatrix}.
#' @param genome_build The genome build that the peak sequences should be
#' derived from.
#' @param shuffle_k K-let size. This option is only used if \code{control_input}
#' is set to \code{"shuffle"}.
#' @param min_score Numeric specifying the minimum score a sequence must pass
#' to be considered a motif.
#' @param optimal_min_score If TRUE, numerical optimisation is used to find an
#' optimal min_score parameter for the motif search. We use the differential
#' evolution algorithm implemented in deoptim.
#' @param num_samples Number of samples to use to calculate the optimal
#' min_score threshold. This option is only used if optimal_min_score is set to
#' TRUE.
#' @param sample_size Number of peaks in each sample. This option is only used
#' if optimal_min_score is set to TRUE.
#' @param num_threads Number of threads to use for min_score optimisation. We
#' recommend setting this equal to the number of samples for the greatest speed
#' up.
#' @param deoptim_lower The lower bound of the parameter search space.
#' @param deoptim_upper The upper bound of the parameter search space.
#' @param deoptim_np The number of population members.
#' @param deoptim_itermax The number of population generations the optimisation
#' procedure will use.
#' @param deoptim_strategy The differential evolution strategy the optimisation
#' procedure will use.
#' @param seed Set this to an integer if you want the same random background
#' sequences across function calls (given the same peak_input).
#'
#' @examples
#' \dontrun{
#' peak_file <- system.file("extdata",
#'                          "rep1_peaks.narrowPeak",
#'                          package = "MotifStats"
#'                          )
#' data("creb_motif", package = "MotifStats")
#'
#' peak_proportion(
#'   peak_file = peak_file,
#'   pwm = creb_motif,
#'   genome_build = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38,
#'   min_score = NULL,
#'   optimal_min_score = TRUE,
#'   num_samples = 4,
#'   sample_size = 250,
#'   num_threads = 4L,
#'   deoptim_lower = 0.5,
#'   deoptim_upper = 1,
#'   deoptim_np = 20,
#'   deoptim_itermax = 25,
#'   deoptim_strategy = 6,
#'   seed = 123 # set seed for reproducibility
#' )
#' }
#'
#' @seealso \link[DEoptim]{DEoptim}, \link[TFBSTools]{searchSeq}
#' @export
peak_proportion <- function(peak_input,
                            control_input = "shuffle",
                            pwm,
                            genome_build,
                            shuffle_k = 2,
                            min_score = 0.8,
                            optimal_min_score = FALSE,
                            num_samples = 4,
                            sample_size = 250,
                            num_threads = 1L,
                            deoptim_lower = 0.5,
                            deoptim_upper = 1,
                            deoptim_np = 20,
                            deoptim_itermax = 25,
                            deoptim_strategy = 6,
                            seed = NULL) {
  if (!is.null(seed)) set.seed(seed)

  peaks_and_seqs <- check_peak_input(peak_input = peak_input,
                                     genome_build = genome_build)
  peaks <- peaks_and_seqs[[1]] # 1st position of peaks_and_seqs vector
  peak_sequences <- peaks_and_seqs[[2]] # 2nd position of peaks_and_seqs vector

  # ctrl_sequences <- check_control_input(control_input = control_input,
  #                                       shuffle_k = shuffle_k,
  #                                       peak_sequences = peak_sequences,
  #                                       genome_build = genome_build)
  if (optimal_min_score) {
    min_score <- optimal_min_score(peaks = peaks,
                                   control_input = control_input,
                                   pwm = pwm,
                                   genome_build = genome_build,
                                   num_samples = num_samples,
                                   sample_size = sample_size,
                                   num_threads = num_threads,
                                   deoptim_lower = deoptim_lower,
                                   deoptim_upper = deoptim_upper,
                                   deoptim_np = deoptim_np,
                                   deoptim_itermax = deoptim_itermax,
                                   deoptim_strategy = deoptim_strategy,
                                   seed = seed)
    messager("Optimal min_score threshold found:", min_score,
             "\n\nThis threshold will now be applied to the full dataset")

  } else if (!is.null(min_score)) {
    min_score <- min_score
  } else {
    stopper("Either optimal_min_score is set to TRUE or min_score must be",
            "supplied.")
  }

  # hits <- get_motif_hits(
  #   peak_sequences = peak_sequences,
  #   pwm = pwm,
  #   min_score = min_score,
  #   genome_build = genome_build
  # )
  # ctrl_hits <- get_motif_hits(
  #   peak_sequences = ctrl_sequences,
  #   pwm = pwm,
  #   min_score = min_score,
  #   genome_build = genome_build
  # )

  # Using FIMO instead
  fimo_df <- memes::runFimo(peak_sequences, motifs = pwm, thresh = 1e-4)
  print("done")
  names(fimo_df) <- GenomicRanges::seqnames(fimo_df)
  onehit_peak_names <- unique(names(fimo_df))
  onehit_peaks <- peak_sequences[names(peak_sequences) %in% onehit_peak_names, ]

  # 1 motif per peak
  # onehit_peak_names <- names(hits)[sapply(hits, length) > 0]
  # onehit_peaks <- peak_sequences[names(peak_sequences) %in% onehit_peak_names, ]
  #
  # onehit_ctrl_names <- names(ctrl_hits)[sapply(ctrl_hits, length) > 0]
  # onehit_ctrl <- ctrl_sequences[names(ctrl_sequences) %in% onehit_ctrl_names, ]

  return(
    list(
      one_hit_peak_prop = onehit_peaks,
      proportion_1_motif = length(onehit_peaks) / length(peaks),
      #ctrl_proportion_1_motif = length(onehit_ctrl) / length(ctrl_sequences),
      optimal_score = min_score
    )
  )
}
